#!/bin/sh
#
#  ChromeSSB: Run a Chrome SSB
#
#  Copyright (C) 2015 David Marmor
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 


# SAFESOURCE -- safely source a script (version 1.0)
function safesource {
    if [ "$2" ] ; then
	fileinfo="$2"
    else
	fileinfo="$1"
	[[ "$fileinfo" =~ /([^/]+)$ ]] && fileinfo="${BASH_REMATCH[1]}"
    fi
    
    if [ -e "$1" ] ; then
	source "$1" > /dev/null 2>&1
	if [ $? != 0 ] ; then
	    cmdtext="Unable to load $fileinfo."
	    return 1
	fi
    else
	cmdtext="Unable to find $fileinfo."
	return 1
    fi

    return 0
}


# ALERT -- display an alert dialogue
function alert {  #  MESSAGE TITLE ICON (stop, caution, note)
    local msg="$1" ; shift
    local title="$1" ; shift ; [ "$title" ] && title="with title \"$title\""
    local icon="$1" ; shift ; [ "$icon" ] && icon="with icon $icon"
    
    cmdtext=$(osascript -e "display dialog \"$msg\" $icon buttons {\"OK\"} default button \"OK\" $title" 2>&1)
}


# DIALOG -- display a dialog and return the button pressed
function dialog {  # MESSAGE TITLE ICON (if starts with | try app icon first) DEFAULT CANCEL BUTTON1 BUTTON2 BUTTON3 (+ = default, - = cancel)
    local msg="$1" ; shift
    local title_code="$1" ; shift ; [ "$title_code" ] && title_code="with title \"$title_code\""

    # build icon setting code
    local icon="$1" ; shift
    if [ "${icon::1}" = "|" ] ; then
	icon="${icon:1}"
	icon_code="set myIcon to (POSIX file \"$myPath/Contents/Resources/$CFBundleIconFile\")
tell application \"Finder\"
    if (not exists myIcon) or ((the name extension of (myIcon as alias)) is not \"icns\") then
        set myIcon to $icon
    end if
end tell"
    else
	icon_code="set myIcon to $icon"
    fi
    
    # build button list
    local buttonlist=
    local button=
    local button_default=
    local button_cancel=
    local try_start=
    local try_end=
    for button in "${@:1:3}" ; do
	# identify default and cancel buttons
	if [ "${button::1}" = "+" ] ; then
	    button="${button:1}"
	    button_default="default button \"$button\""
	elif [ \( "${button::1}" = "-" \) -o \( "$button" = "Cancel" \) ] ; then
	    button="${button#-}"
	    button_cancel="cancel button \"$button\""
	    try_start="try"
	    try_end="on error number -128
    \"$button\"
end try"
	fi
	
	# add to button list
	buttonlist="$buttonlist, \"$button\""
    done
    buttonlist="{ ${buttonlist:2} }"
    
    # run the dialog
    osascript -e "$icon_code
$try_start
    button returned of (display dialog \"$msg\" $title_code with icon myIcon buttons $buttonlist $button_default $button_cancel)
$try_end"
}


# ABORT -- display an error dialogue and abort
function abort {
    alert "$1" "Unable to Run" stop
    exit $2
}


# RELAUNCH -- relaunch this app after a delay
function relaunch {
    [ "$1" ] && sleep "$1"
    open "$myPath"
}


# BOOTSTRAP RUNTIME SCRIPT

# determine location of runtime script
myPath=$(cd "$(dirname "$0")/../.."; pwd)
myContents="$myPath/Contents"
[ $? != 0 ] && abort "Unable to determine MakeChromeSSB path." 1
[[ "$myPath" =~ \.[aA][pP][pP]$ ]] || abort "Unexpected MakeChromeSSB path." 1

# load main runtime functions
safesource "${myContents}/Resources/Scripts/runtime.sh" "runtime script"
[ $? != 0 ] && abort "$cmdtext" 1


# GET BASIC APP INFORMATION

# load config.sh file
safesource "$myContents/$appConfigScript" "config file"
[ $? != 0 ] && abort "$cmdtext" 1

# get Google Chrome info
chromeinfo
[ $? != 0 ] && abort "$cmdtext" 1

# by default we don't need to update the config file
updateconfig=


# CHECK FOR NEW VERSION OF MAKECHROMESSB AND UPDATE

mcssbinfo
if [ \( $? = 0 \) -a "$(newversion "$SSBVersion" "$mcssbVersion")" ] ; then

    updateErr=

    # Ask about updating
    doUpdate=$(dialog "A new version of the MakeChromeSSB runtime was found ($mcssbVersion). Would you like to update now?" \
		      "Update" \
		      "|caution" \
		      "+Update" \
		      "-Later" \
		      "Don't Ask Again For This Version" )
    
    if [ $? != 0 ] ; then
	cmdtext="AppleScript error."
	updateErr=1
    fi

    if [ \( ! "$updateErr" \) ] ; then
	case "$doUpdate" in
	    Update)
		# read in the new runtime
		safesource "${mcssbPath}/Contents/Resources/Runtime/Resources/Scripts/runtime.sh" "updated runtime script"
		if [ $? != 0 ] ; then
		    updateErr=1
		else
		    # use new runtime to update the SSB
		    updatessb "$myPath"
		    [ $? != 0 ] && updateErr=1

		    # relaunch!
		    relaunch 1 &
		    disown -ar
		    exit 0
		fi
		;;
	    Later)
		# don't update
		doUpdate=
		;;
	    *)
		# pretend we're already at the current version
		SSBVersion="$mcssbVersion"
		updateconfig=1
		;;
	esac
    fi

    # alert the user to any error, but leave the SSB functional
    if [ "$updateErr" ] ; then
	# Please try update again later.
	alert "$cmdtext Please try update again later."
    fi        
fi


# CHECK AND UPDATE CHROME LINKS

# update config variable
if [ "$SSBChromePath" != "$chromePath" ] ; then
    SSBChromePath="$chromePath"
    updateconfig=1
fi

# check if the Chrome link is either: not a link; not executable; or not pointing to the real Chrome executable
myChromeLink="$myContents/$appChromeLink"
if [ \( ! -h "$myChromeLink" \) -o \
	\( ! -x "$myChromeLink" \) -o \
	\( "$chromeExec" != "$(readlink "$myChromeLink" 2> /dev/null)" \) ] ; then
    
    # display a relink alert

    dialog "Google Chrome appears to have moved. Attempting to relink..." "Relinking Chrome" "|caution" "+OK" > /dev/null
    
    # relink to Google Chrome
    linkchrome "$myContents"
    [ $? != 0 ] && abort "$cmdtext" 1
fi

# check for new version of Chrome and update
if [ "$SSBChromeVersion" != "$chromeVersion" ] ; then
    
    # display a Chrome update alert
    dialog "New version of Google Chrome found ($chromeVersion). Updating SSB..." "New Chrome Version" "|caution" "+OK"
    
    # set new version number for config file
    SSBChromeVersion="$chromeVersion"
    
    # use new runtime to update the SSB
    updatessb "$myPath" '' ChromeOnly
    [ $? != 0 ] && abort "$cmdtext" 1
    
    # relaunch!
    relaunch 1 &
    disown -ar
    exit 0
fi

# update config file
if [ "$updateconfig" ] ; then
    writeconfig "$myContents"
    [ $? != 0 ] && abort "$cmdtext" 1
fi


# MAKE SURE NATIVE HOST IS INSTALLED

# set up host file paths
hostId="SSBHOSTID"
hostManifest="${hostId}.json"
hostScript="${hostId}-host.py"
hostDir="NativeMessagingHosts"
hostInstallPath="$SSBProfilePath/$hostDir"
hostScriptInstalled="$hostInstallPath/$hostScript"
hostManifestInstalled="$hostInstallPath/$hostManifest"

# check if we need to install native messaging host
doHostInstall=
if [[ ! -x "$hostScriptInstalled" ]] ; then
    doHostInstall=1
else
    hostVersion=$("$hostScriptInstalled" -v 2>&1)
    [[ $(newversion "$hostVersion" "$mcssbVersion") ]] && doHostInstall=1
fi
[[ ! -e "$hostManifestInstalled" ]] && doHostInstall=1

# do the installation if necessary
if [[ "$doHostInstall" ]] ; then
    hostError=
    hostSourcePath="$myContents/Resources/$hostDir"
    
    # create the install directory
    mkdir -p "$hostInstallPath" 2>&1 /dev/null
    if [ $? = 0 ] ; then
	hostError=1
	cmdtext="Unable to create messaging host installation folder."
    fi
    
    # stream-edit the manifest file
    hostManifestTmp=$(tempname "$hostManifestInstalled")
    sed "s/SSBHOSTPATH/${hostScriptInstalled//\//\\/}/" "$hostSourcePath/$hostManifest" > "$hostManifestTmp" 2> /dev/null
    if [ $? != 0 ] ; then
	hostError=1
	cmdtext="Unable to copy messaging host manifest."
    fi
    
    # stream-edit the host script
    if [[ ! "$hostError" ]] ; then
	hostScriptTmp=$(tempname "$hostScriptInstalled")
	sed "s/SSBID/$CFBundleIdentifier/" "$hostSourcePath/$hostScript" > "$hostScriptTmp" 2> /dev/null
	if [ $? != 0 ] ; then
	    hostError=1
	    cmdtext="Unable to copy messaging host."
	fi	
    fi

    # fix host script permissions
    if [[ ! "$hostError" ]] ; then
	/bin/chmod 755 "$hostScriptTmp" > /dev/null 2>&1
	if [ $? != 0 ] ; then
	    hostError=1
	    cmdtext="Unable to make messaging host executable."
	fi
    fi
    
    # move both files to permanent homes
    if [[ ! "$hostError" ]] ; then
	permanent "$hostManifestTmp" "$hostManifestInstalled" "messaging host manifest"
	[ $? != 0 ] && hostError=1
    fi
    if [[ ! "$hostError" ]] ; then
	permanent "$hostScriptTmp" "$hostScriptInstalled" "messaging host"
	[ $? != 0 ] && hostError=1
    fi

    # report error, but don't abort
    if [[ "$hostError" ]] ; then
	alert "$cmdtext The SSB will still work, but the companion SSB Redirect extension won't." "Messaging Host Error" caution
    fi
fi


# LAUNCH THE SSB

exec "$myChromeLink" --user-data-dir="$SSBProfilePath" "${SSBCommandLine[@]}"
